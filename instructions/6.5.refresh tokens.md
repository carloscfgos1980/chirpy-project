# Refresh tokens are used to keep users logged in for longer periods of time, and they can be revoked if a user's access token is compromised. 

This was hard to understand but I finally got it. The goal is to send this refresh token to the client and this can be used to get a new token that we need to acces to protected routes, like creating a chirp

1. <sql/schemas/004_refresh_tokens.sql> Create the schema for the new table:
-- +goose Up
CREATE TABLE refresh_tokens (
    token TEXT PRIMARY KEY,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    expires_at TIMESTAMP NOT NULL,
    revoked_at TIMESTAMP
);

-- +goose Down
DROP TABLE refresh_tokens;

2. <sql/queries/refresh_tokens.sql>. Create a query to add data to refresh_tokens table. "revoke_at" field must be leave as NULL

-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (token, created_at, updated_at, user_id, expires_at)
VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3
)
RETURNING *;

3. Create a query to revoke the refresh token. In this case, "revoked_at" is given the value of current time:

-- name: RevokeRefreshToken :one
UPDATE refresh_tokens SET revoked_at = NOW(),
updated_at = NOW()
WHERE token = $1
RETURNING *;


4. Querie to get the refresh token, passing the refresh_toqken value and the condiction that "revoked_at" is NOT NULL:

-- name: GetUserFromRefreshToken :one
SELECT users.* FROM users
JOIN refresh_tokens ON users.id = refresh_tokens.user_id
WHERE refresh_tokens.token = $1
AND revoked_at IS NULL
AND expires_at > NOW();

5. <handler_login.go>. Add refresh toqken to the response:

 type response struct {
  User
  Token        string `json:"token"`
  RefreshToken string `json:"refresh_token"`
 }

6. Create a refresh token:

 refreshToken := auth.MakeRefreshToken()

7. Add the refresh token to database:

 _, err = cfg.db.CreateRefreshToken(r.Context(), database.CreateRefreshTokenParams{
  UserID:    user.ID,
  Token:     refreshToken,
  ExpiresAt: time.Now().UTC().Add(time.Hour *24* 60),
 })
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't save refresh token", err)
  return
 }

8. Resppnse with the User, the token and the refresh_token
 respondWithJSON(w, http.StatusOK, response{
  User: User{
   ID:        user.ID,
   Email:     user.Email,
   CreatedAt: user.CreatedAt,
   UpdatedAt: user.UpdatedAt,
  },
  Token:        token,
  RefreshToken: refreshToken,
 })

9. <handler_refresh.go> This function handle the refresh token that come in the request header as a bearer <token>. It will use this value to look for the user and then create a new token that is sent as resppnse to the client


func (cfg *apiConfig) handlerRefresh(w http.ResponseWriter, r*http.Request) {
 type response struct {
  Token string `json:"token"`
 }

 refreshToken, err := auth.GetBearerToken(r.Header)
 if err != nil {
  respondWithError(w, http.StatusBadRequest, "Couldn't find token", err)
  return
 }

 user, err := cfg.db.GetUserFromRefreshToken(r.Context(), refreshToken)
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Couldn't get user for refresh token", err)
  return
 }

 accessToken, err := auth.MakeJWT(
  user.ID,
  cfg.jwtSecret,
  time.Hour,
 )
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Couldn't validate token", err)
  return
 }

 respondWithJSON(w, http.StatusOK, response{
  Token: accessToken,
 })
}

10. <handler_refresh.go> Revoke refresh_token. This will set a time vale to the "revoke_at" column so this refresh token can not be longer used. And it will respond with 204 code with not body text:

func (cfg *apiConfig) handlerRefresh(w http.ResponseWriter, r*http.Request) {
 type response struct {
  Token string `json:"token"`
 }

 refreshToken, err := auth.GetBearerToken(r.Header)
 if err != nil {
  respondWithError(w, http.StatusBadRequest, "Couldn't find token", err)
  return
 }

 user, err := cfg.db.GetUserFromRefreshToken(r.Context(), refreshToken)
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Couldn't get user for refresh token", err)
  return
 }

 accessToken, err := auth.MakeJWT(
  user.ID,
  cfg.jwtSecret,
  time.Hour,
 )
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Couldn't validate token", err)
  return
 }

 respondWithJSON(w, http.StatusOK, response{
  Token: accessToken,
 })
}

func (cfg *apiConfig) handlerRevoke(w http.ResponseWriter, r*http.Request) {
 refreshToken, err := auth.GetBearerToken(r.Header)
 if err != nil {
  respondWithError(w, http.StatusBadRequest, "Couldn't find token", err)
  return
 }

 _, err = cfg.db.RevokeRefreshToken(r.Context(), refreshToken)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't revoke session", err)
  return
 }

 w.WriteHeader(http.StatusNoContent)
}

12. <main.go> Create the routes to refresh and revoke the refresh token:

 mux.HandleFunc("POST /api/refresh", apiCfg.handlerRefresh)
 mux.HandleFunc("POST /api/revoke", apiCfg.handlerRevoke)

