# 28/01/26

# Goals of This Course
Understand what web servers are and how they power real-world web applications
Build a production-style HTTP server in Go, without the use of a framework
Use JSON, headers, and status codes to communicate with clients via a RESTful API
Learn what makes Go a great language for building fast web servers
Use type safe SQL to store and retrieve data from a Postgres database
Implement a secure authentication/authorization system with well-tested cryptography libraries
Build and understand webhooks and API keys
Document the REST API with markdown

# Server:
A web server is just a computer that serves data over a network, typically the Internet. Servers run software that listens for incoming requests from clients. When a request is received, the server responds with the requested data.

Any server worth its salt can handle many requests at the same time. In Go, we use a new goroutine for each request to handle them concurrently. Let's start by practicing with goroutines.

# Goroutines in Servers
In Go, goroutines are used to serve many requests at the same time, but not all servers are quite so performant.

Go was built by Google, and one of the purposes of its creation was to power Google's massive web infrastructure. Go's goroutines are a great fit for web servers because they're lighter weight than operating system threads, but still take advantage of multiple cores. Let's compare a Go web server's concurrency model to other popular languages and frameworks.

Node.js / Express.js
In JavaScript land, servers are typically single-threaded. A Node.js server (often using the Express framework) only uses one CPU core at a time. It can still handle many requests at once by using an async event loop. That just means whenever a request has to wait on I/O (like to a database), the server puts it on pause and does something else for a bit.

This might sound horribly inefficient, but it's not too bad. Node servers do just fine with the I/O workloads associated with most CRUD apps (Where processing is offloaded to the Database). You only start to run into trouble with this model when you need your server to do CPU-intensive work.

Takeaways
Go servers are great for performance whether the workload is I/O or CPU-bound
Node.js and Express work well for I/O-bound tasks, but struggle with CPU-bound tasks
I'm not saying Go is always "better" than JavaScript when it comes to back-end development, but it generally outperforms when it comes to computational speed.

# 1. Start a server
1. Create a new http server mux
 mux := http.NewServeMux()

2. Create a new http.Server struct.
Use the new "ServeMux" as the server's handler
Set the .Addr field to ":8080"
 srv := &http.Server{
  Addr:    ":8080",
  Handler: mux,
 }

3. Use the server's ListenAndServe method to start the server
 err := srv.ListenAndServe()
 if err != nil {
  log.Printf("Server failed to start: %v", err)
 }

# 2. Fileserver

To serve the client. I moved the index.html to a different dirctory (client)

- Use the new http server mux the pass to arguments :
path: "/"
standard http.FileServer as the handler:

 mux.Handle("/", http.FileServer(http.Dir("../client")))

- http.Dir => indicates that the root is where main.go file is

# 3 Serving Images

I just add the folder with the image. No need to change the code

# 4 Custom Handlers

Crete a handler to check the health of the server
 mux.HandleFunc("/healthz", handlerReadiness)


readiness.go
func handlerReadiness(w http.ResponseWriter, r *http.Request) {
 w.Header().Add("Content-Type", "text/plain; charset=utf-8")
 w.WriteHeader(http.StatusOK)
 w.Write([]byte(http.StatusText(http.StatusOK)))
}
