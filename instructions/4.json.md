# 4.1 JSON

1. <json.go>Create a file to handle the json responses:

func respondWithError(w http.ResponseWriter, code int, msg string, err error) {
 if err != nil {
  log.Println(err)
 }
 if code > 499 {
  log.Printf("Responding with 5XX error: %s", msg)
 }
 type errorResponse struct {
  Error string `json:"error"`
 }
 respondWithJSON(w, code, errorResponse{
  Error: msg,
 })
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
 w.Header().Set("Content-Type", "application/json")
 dat, err := json.Marshal(payload)
 if err != nil {
  log.Printf("Error marshalling JSON: %s", err)
  w.WriteHeader(500)
  return
 }
 w.WriteHeader(code)
 w.Write(dat)
}

2. <chirpy-validate>
For this exercise we are told that the body of the request is a string and it can not be longer that 140 characters.

2.1 Create the parameters struc:
 type parameters struct {
  Body string `json:"body"`
 }
 * The struct fields must be with capital letters so they can be exported

2.2 struct with the return value. This will be passing to the "respondWithJSON" function
 type returnVals struct {
  Valid bool `json:"valid"`
 }

2.3 create a variable and populate it with the request's body:
 decoder := json.NewDecoder(r.Body)
 params := parameters{}
 err := decoder.Decode(&params)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't decode parameters", err)
  return
 }

 2.4 Meet the condiction of the assignment:
  const maxChirpLength = 140
 if len(params.Body) > maxChirpLength {
  respondWithError(w, http.StatusBadRequest, "Chirp is too long", nil)
  return
 }

 2.5 Ok response:
  respondWithJSON(w, http.StatusOK, returnVals{
  Valid: true,
 })


<function:>
func handlerChirpsValidate(w http.ResponseWriter, r *http.Request) {
 type parameters struct {
  Body string `json:"body"`
 }
 type returnVals struct {
  Valid bool `json:"valid"`
 }

 decoder := json.NewDecoder(r.Body)
 params := parameters{}
 err := decoder.Decode(&params)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't decode parameters", err)
  return
 }

 const maxChirpLength = 140
 if len(params.Body) > maxChirpLength {
  respondWithError(w, http.StatusBadRequest, "Chirp is too long", nil)
  return
 }

 respondWithJSON(w, http.StatusOK, returnVals{
  Valid: true,
 })
}

# 4.2 The profane.
Not only do we validate that Chirps are under 140 characters, but we also have a list of words that are not allowed.

Assignment
We need to update the /api/validate_chirp endpoint to replace all "profane" words with 4 asterisks: ****.

Assuming the length validation passed, replace any of the following words in the Chirp with the static 4-character string ****:

kerfuffle
sharbert
fornax
Be sure to match against uppercase versions of the words as well, but not punctuation. "Sharbert!" does not need to be replaced, we'll consider it a different word due to the exclamation point. Finally, instead of the valid boolean, your handler should return the cleaned version of the text in a JSON response:

1. <handler_validate.go> Change the struct for the response:
 type returnVals struct {
  CleanedBody string `json:"cleaned_body"`
 }

2. Create a function that will sustitute the bad words. This take the string (words) from the request's body and a map which keys would be the "bad words" and a the value would be empty structs
func getCleanedBody(body string, badWords map[string]struct{}) string {
 words := strings.Split(body, " ")
 for i, word := range words {
  loweredWord := strings.ToLower(word)
  if _, ok := badWords[loweredWord]; ok {
   words[i] = "****"
  }
 }
 cleaned := strings.Join(words, " ")
 return cleaned
}

2.1 split the string into words:
 words := strings.Split(body, " ")

2.2 start a loop over the words:
 for i, word := range words {

2.3 convert the words to lower letters:
  loweredWord := strings.ToLower(word)

2.4 conditction to check if the "bad word" is a key in the dictionary, it it does exist the change the word by getting the index of the words:
  if _, ok := badWords[loweredWord]; ok {
   words[i] = "****"
  }

2.5 Joing the splitted words:
 cleaned := strings.Join(words, " ")

2.6 return the cleaned string (words)

3. Create a map inside handlerChirpsValidate function with the "bad words" as key from the map:
 badWords := map[string]struct{}{
  "kerfuffle": {},
  "sharbert":  {},
  "fornax":    {},
 }

4. Call "getCleanedBody" function and pass the 2 arguments: request's body and the badwords map:

 cleaned := getCleanedBody(params.Body, badWords)

5. Response with Cleaned text:

 respondWithJSON(w, http.StatusOK, returnVals{
  CleanedBody: cleaned,
 })
