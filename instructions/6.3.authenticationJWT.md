Authentication With JWTs
Let's take a closer look at how JWTs work in the authentication flow.

Step 1: Login
It would be pretty annoying if you had to enter your username and password every time you wanted to make a request to an API. Instead, after a user enters a username and password, our server should respond with a token (JWT) that's saved in the client's device.

The token remains valid until it expires, at which point the user will need to log in again.

Step 2: Using the Token
When the user wants to make a request to the API, they send the token along with the request in the HTTP headers. The server can then verify that the token is valid, which means the user is who they say they are.

1. Generate a secret:
openssl rand -base64 64

2. <.env> Create a variable for the  JWT secret

3. <main.go>. Add a fiel into apiConfig.

type apiConfig struct {
 fileserverHits atomic.Int32
 db             *database.Queries
 platform       string
 jwtSecret      string
}

4. Get the secret value:
 jwtSecret := os.Getenv("JWT_SECRET")
 if jwtSecret == "" {
  log.Fatal("JWT_SECRET must be set")
 }

5. Add the value to the apiCfg variable:
 apiCfg := apiConfig{
  fileserverHits: atomic.Int32{},
  db:             dbQueries,
  platform:       platform,
  jwtSecret:      jwtSecret,
 }

6. <internal/auth/auth.go>. Create a function to get the token. It come in the header of the request in a string that starts with "Bearer" then 1 white space and the token

// GetBearerToken -
func GetBearerToken(headers http.Header) (string, error) {
 authHeader := headers.Get("Authorization")
 if authHeader == "" {
  return "", ErrNoAuthHeaderIncluded
 }
 splitAuth := strings.Split(authHeader, " ")
 if len(splitAuth) < 2 || splitAuth[0] != "Bearer" {
  return "", errors.New("malformed authorization header")
 }

 return splitAuth[1], nil
}


7. <habler_login.go>. Add the token in the struct response:

 type response struct {
  User
  Token string `json:"token"`
 }

8. use the makeToken function:

 token, err := auth.MakeJWT(
  user.ID,
  cfg.jwtSecret,
  24*7*time.Hour,
 )

9. Response with the user data, escept password and the token:

 respondWithJSON(w, http.StatusOK, response{
  User: User{
   ID:        user.ID,
   Email:     user.Email,
   CreatedAt: user.CreatedAt,
   UpdatedAt: user.UpdatedAt,
  },
  Token: token,
 })

10. <handler_chirp_create.go>. The body of post chirp request will only the body as q key and the text as value.

 type parameters struct {
  Body string `json:"body"`
 }

11. Get the token:

 token, err := auth.GetBearerToken(r.Header)
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "No authorization token included", err)
  return
 }

12. Get the userId using the token:

 userID, err := auth.ValidateJWT(token, cfg.jwtSecret)
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Invalid authorization token", err)
  return
 }

13. Copy the chirp into dabase:

 chirp, err := cfg.db.CreateChirp(r.Context(), database.CreateChirpParams{
  Body:   cleaned,
  UserID: userID,
 })


* It took me a while to figure it out how to send the request with Postman:
Once I have the token, I have to click authorization tab and add a Bearer token with the ""!