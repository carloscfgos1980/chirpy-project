Webhooks
Webhooks sound like a scary advanced concept, but they're quite simple.

A webhook is just an event that's sent to your server by an external service when something happens.

For example, here at Boot.dev we use Stripe as a third-party payment processor. When a student makes a payment, Stripe sends a webhook to the Boot.dev servers so that we can unlock the student's membership.

Student makes a payment to stripe
Stripe processes the payment
If the payment is successful, Stripe sends an HTTP POST request to <https://api.boot.dev/stripe/webhook> (that's not the real URL, but you get the idea)
That's it! The only real difference between a webhook and a typical HTTP request is that the system making the request is an automated system, not a human loading a webpage or web app. As such, webhook handlers must be idempotent because the system on the other side may retry the request multiple times.

Idempo... What?
Idempotent, or "idempotence", is a fancy word that means "the same result no matter how many times you do it". For example, your typical POST /api/chirps (create a chirp) endpoint will not be idempotent. If you send the same request twice, you'll end up with two chirps with the same information but different IDs.

Webhooks, on the other hand, should be idempotent, and it's typically easy to build them this way because the client sends some kind of "event" and usually provides its own unique ID.


1. <sql/schema/005_chirpy_red.sql> Create a new goose migration to add a column to table "users":
-- +goose Up
ALTER TABLE users
ADD COLUMN is_chirpy_red BOOLEAN NOT NULL
DEFAULT FALSE;

-- +goose Down
ALTER TABLE users
DROP COLUMN is_chirpy_red;

2. In the terminal with server as a root:
cd sql/schema
goose postgres postgres://carlosinfante:@localhost:5432/chirpy1 up

3. <sql/queries/users.sql>. Update users querie in order to update the new column (is_chirpy_red)

-- name: UpgradeToChirpyRed :one
UPDATE users SET is_chirpy_red = true, updated_at = NOW()
WHERE id = $1
RETURNING *;

4. In the terminal with server as root
sqlc generate


5. <handler_webhooks.go> Create the function to handle the webhook

func (cfg *apiConfig) handlerWebhook(w http.ResponseWriter, r*http.Request) {

// struct for paramater from the request
 type parameters struct {
  Event string `json:"event"`
  Data  struct {
   UserID uuid.UUID `json:"user_id"`
  }
 }

// Decode json into go and save it in variable "params"
 decoder := json.NewDecoder(r.Body)
 params := parameters{}
 err := decoder.Decode(&params)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't decode parameters", err)
  return
 }

// if it is the wrong event, just return 204
 if params.Event != "user.upgraded" {
  w.WriteHeader(http.StatusNoContent)
  return
 }


// update "is_chirpy_red" column in "users" table
 _, err = cfg.db.UpgradeToChirpyRed(r.Context(), params.Data.UserID)
 if err != nil {
  if errors.Is(err, sql.ErrNoRows) {
   respondWithError(w, http.StatusNotFound, "Couldn't find user", err)
   return
  }
  respondWithError(w, http.StatusInternalServerError, "Couldn't update user", err)
  return
 }


// respond with 204
 w.WriteHeader(http.StatusNoContent)
}

6. <handle_user_create.go> Update User struct for the new field (is_chirpy_red):
type User struct {
 ID          uuid.UUID `json:"id"`
 CreatedAt   time.Time `json:"created_at"`
 UpdatedAt   time.Time `json:"updated_at"`
 Email       string    `json:"email"`
 Password    string    `json:"password"`
 IsChirpyRed bool      `json:"is_chirpy_red"`
}

7. Update the response from handlerUsersCreate, handlerLogin and handlerUsersUpdate to return all "is_chripy_red" value:

 respondWithJSON(w, http.StatusCreated, response{
  User: User{
   ID:          user.ID,
   CreatedAt:   user.CreatedAt,
   UpdatedAt:   user.UpdatedAt,
   Email:       user.Email,
   IsChirpyRed: user.IsChirpyRed,
  },
 })

8. <main.go> Create a route to update "is_chirpy_red" column in "users" table:
 mux.HandleFunc("POST /api/polka/webhooks", apiCfg.handlerWebhook)
