# 6.1 Authentication With Passwords


1. Download Aragon library in order to hash the password:
form server directory
go get github.com/alexedwards/argon2id

2. <sql/schemas/003_password.sql>. Create anotther goose migration to add a column to "users" table:

-- +goose Up
ALTER TABLE users
ADD COLUMN hashed_password TEXT NOT NULL
DEFAULT 'unset';

-- +goose Down
ALTER TABLE users
DROP COLUMN hashed_password;

3. Add the column to the database. In the terminal on server as a root directory:
cd sql/schema
goose postgres postgres://carlosinfante:@localhost:5432/chirpy1 up

4. <sql/queries.users.sql>. Update the querie so it will accept to arguments (userId and password):
-- name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, email, hashed_password)
VALUES (
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1,
    $2
)
RETURNING *;

* I for got to this and I was having a trouble later when I was writing the login function

5. <sql/queries/users.sql> Add another querie to get a user by email:
-- name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, email, hashed_password)
VALUES (
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1,
    $2
)
RETURNING *;

6. Generate the codefor the new changes. In the terminal and server as a root directory:
sqlc generate

7. <internal/auth/auth.go> Function to hash passoword. it accept a string (password) and return another string (hashed password) and a error:

func HashPassword(password string) (string, error) {
 hash, err := argon2id.CreateHash(password, argon2id.DefaultParams)
 if err != nil {
  return "", err
 }
 return hash, nil
}

8. <internal/auth/auth.go> Chck password. It takes 2 arguments: password and hashed passwod. And it returns a boolena and an error:

func CheckPasswordHash(password, hash string) (bool, error) {
 match, err := argon2id.ComparePasswordAndHash(password, hash)
 if err != nil {
  return false, err
 }
 return match, nil
}

9. <handler_login.go>. Function to handle login:
func (cfg *apiConfig) handlerLogin(w http.ResponseWriter, r*http.Request) {

// struct where the request's data will be saved
 type parameters struct {
  Password string `json:"password"`
  Email    string `json:"email"`
 }

 //struct for the response
 type response struct {
  User
 }

//convert data from json to go
 decoder := json.NewDecoder(r.Body)
 params := parameters{}
 err := decoder.Decode(&params)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't decode parameters", err)
  return
 }


// check if the user exist in database
 user, err := cfg.db.GetUserByEmail(r.Context(), params.Email)
 if err != nil {
  respondWithError(w, http.StatusUnauthorized, "Incorrect email or password", err)
  return
 }

// check if the passwod is correct
 match, err := auth.CheckPasswordHash(params.Password, user.HashedPassword)
 if err != nil || !match {
  respondWithError(w, http.StatusUnauthorized, "Incorrect email or password", err)
  return
 }


// respond with ok status and the body of the response is the user data, except the password
 respondWithJSON(w, http.StatusOK, response{
  User: User{
   ID:        user.ID,
   Email:     user.Email,
   CreatedAt: user.CreatedAt,
   UpdatedAt: user.UpdatedAt,
  },
 })
}

10. <handler_user_create.go> Update the User so we can store all the password as a hash in the database:

10.1 Add a parameter to User struct
 Password  string    `json:"password"`

10.2 Update paramters struct:
 type parameters struct {
  Email    string `json:"email"`
  Password string `json:"password"`
 }

10.3 Hash the password:
 hashedPassword, err := auth.HashPassword(params.Password)
 if err != nil {
  respondWithError(w, http.StatusInternalServerError, "Couldn't hash password", err)
  return
 }

10.4 Save to the database:

 user, err := cfg.db.CreateUser(r.Context(), database.CreateUserParams{
  Email:          params.Email,
  HashedPassword: hashedPassword,
 })

11. <main.go> Create the route for login:
 mux.HandleFunc("POST /api/login", apiCfg.handlerLogin)

12. <internal/auth/auth_test.go>. Bunch of test to check if the hashpaword function works as expected!

12.1 to run de test, in the terminal, I need to go to the directory where the test is and run the following command:
go test -v
